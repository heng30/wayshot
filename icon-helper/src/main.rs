use anyhow::{bail, Result};
use clap::Parser;
use regex::Regex;
use walkdir::WalkDir;
use std::{fs, io::Write, collections::HashSet, path::Path};

#[derive(Parser, Debug)]
#[command(
    name = "icon-helper",
    version = "v1.0.0",
    about = "A tool to generate the `icon.slint` for this project.",
    long_about = None
)]

struct Args {
    /// Input directory
    #[arg(short, long, default_value = ".")]
    input_dir: String,

    /// Output directory
    #[arg(short, long, default_value = ".")]
    output_dir: String,

    /// Strip unused icons
    #[arg(short, long)]
    strip: bool,
}

#[derive(Debug)]
pub struct DirectoryInfo {
    pub dir_name: String,
    pub files: Vec<FileInfo>,
}

#[derive(Debug)]
pub struct FileInfo {
    pub full_name: String,
    pub name_without_extension: String,
}

fn main() -> Result<()> {
    let args = Args::parse();

    if args.output_dir.is_empty() {
        bail!("output_dir is empty");
    }

    let icons = extract_icon(".")?;
    let dir_info = get_directory_contents(&args.input_dir)?;
    let dir_counts = dir_info.len();

    let icon_path = Path::new(&args.output_dir).join("icon.slint");
    let mut icon_file = fs::File::create(icon_path)?;

    let mut content = "// Auto-Generated by `make icon`\n\n".to_string();
    content.push_str("export global Icons {\n");

    for (index, dir) in dir_info.into_iter().enumerate() {
        for file in dir.files {
            if args.strip && !icons.contains(&file.name_without_extension)             {
                continue;
            }

            content.push_str("    ");
            content.push_str(&format!(
                r#"out property <image> {}: @image-url("../images/{}/{}");"#,
                file.name_without_extension, dir.dir_name, file.full_name
            ));
            content.push_str("\n");
        }

        if index < dir_counts - 1 {
            content.push_str("\n");
        }
    }

    content.push_str("}");
    icon_file.write(content.as_bytes())?;

    Ok(())
}

pub fn get_directory_contents(dir_path: &str) -> Result<Vec<DirectoryInfo>> {
    let mut result = vec![];
    let path = Path::new(dir_path);
    let entries = fs::read_dir(path)?;

    for entry in entries {
        let entry = entry?;
        let path = entry.path();

        if !path.is_dir() {
            continue;
        }

        if let Some(dir_name) = path.file_name().and_then(|n| n.to_str()) {
            let mut files = vec![];

            if let Ok(sub_entries) = fs::read_dir(&path) {
                for sub_entry in sub_entries {
                    let sub_entry = sub_entry?;
                    let sub_path = sub_entry.path();

                    if !sub_path.is_file() {
                        continue;
                    }

                    if let Some(extension) = sub_path.extension().and_then(|e| e.to_str()) {
                        if extension.to_lowercase() == "svg" || extension.to_lowercase() == "png" {
                            if let Some(file_name) = sub_path.file_name().and_then(|n| n.to_str()) {
                                let name_without_extension = sub_path
                                    .file_stem()
                                    .and_then(|s| s.to_str())
                                    .unwrap_or("")
                                    .to_string();

                                files.push(FileInfo {
                                    full_name: file_name.to_string(),
                                    name_without_extension,
                                });
                            }
                        }
                    }
                }
            }

            result.push(DirectoryInfo {
                dir_name: dir_name.to_string(),
                files,
            });
        }
    }

    Ok(result)
}


fn extract_icon(target_dir: impl AsRef<Path>) -> Result<Vec<String>> {
    let mut icons = HashSet::new();
    let icon_pattern = Regex::new(r#"Icons\.([a-zA-Z_-][a-zA-Z0-9_-]*)"#)?;

    for entry in WalkDir::new(target_dir)
        .into_iter()
        .filter_map(|e| e.ok())
    {
        let path = entry.path();

        if path.to_string_lossy().contains(".git/") || path.to_string_lossy().contains("target/") || path.to_string_lossy().ends_with("icon.slint")  {
            continue;
        }

        if let Some(ext) = path.extension()
            && ext == "slint"
            && let Ok(content) = fs::read_to_string(path)
        {
            for cap in icon_pattern.captures_iter(&content) {
                if let Some(icon_name) = cap.get(1) {
                    icons.insert(icon_name.as_str().to_string());
                }
            }
        }
    }

    Ok(icons.into_iter().collect())
}
